\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\renewcommand{\thesection}{\arabic{section}}
\begin{document}
\title{%
    \begin{minipage}\linewidth
        \centering
        Rapport de Projet d'Algorithmique
        \vskip 3pt
        \large Création d'un Clone d'Hexxagon
    \end{minipage}
}
\author{Guillaume \bsc{Ryckart} - Pablo \bsc{Bourdelas}}
\maketitle

\section{Introduction}

Le but de ce projet est de créer un clone d'hexxagon en C. Le principe du jeu est le suivant. Le tableau est composé de cases hexagonles, sur lequelles deux joueurs déutent avec 2 pions chacun.\\

A chaque tour, un joueur peut soit: copier un de ses pions sur une case vide adjacente, soit déplacer un de ses pions sur une case située à 2 de distance. Dans les deux cas, les pions ennemis adjacents sont pris.\\

De plus, le programme devra également: \begin{itemize}
\item Avoir une interface graphique
\item Gérer des plateaux de différentes tailles
\item Proposer un mode deux joeurs et unmode contre l'odinateur
\item Permettre de bloquer des cases sur le plateau 
\item Mémoriser et afficher les scores
\end {itemize}
\newpage
	
\section{Structure du programme}

	\subsection{Gestion de plateau}
		Le plateau est stocké sous forme d'un tableau.
		Chaque case du plateau est représenté par une structure hexa, qui contient une variable énumérée (qui correspond au contenu de la case) ainsi qu'un tableau de pointeurs sur des cases, qui correspondent aux cases voisines directes de celle-ci.\\
		Le type énuméré prend donc 4 valeurs différentes: 	\begin{itemize}
									\item Joueur 1
								  	\item Joueur 2
								  	\item Vide
								  	\item Bloqué
								  	\end{itemize}
	
		Cette structure permet donc de gérer le bloquage de certaines cases, ainsi qu'un calcule facile des cases ou le joeur peut jouer, ou non. 

	\subsection {Boucle principale}
		
	La boucle caputre les clics de manière non bloquante: elle récupère les déplacements de la souris et valide la position au moment du clic. A partir de celle-ci, sur un clic gauche, elle détermine la position de l'hexagone dans la grille. Suite au second clic gauche, elle valide la seconde position, et determine le mouvement a partir de ces deux positions. Un clic dorit annule la sélection du pion courant.\\

Après la determintation et l'application du coup entré, le jeu vérifie si la partie est finie, via la fonction Update\_Alive, puis passe la main a l'autre joueur. 
	\subsection{Vivacité des pions}

Afin de vérifier si la partie est finie on utilise un principe de vivacité des pions: Un pion est considéré vivant tant que toutes les cases avec lesquelle il peut former un coup valide sont inoccupées, ou occupées par des pions vivants. Une fois le pion mort, il ne peut plus se déplacer, et est stocké dans une liste. Il devient donc facile de vérifier si le jeu est fini: Quand les pions d'un des deux joeurs sont tous morts, la partie est finie.\\

Cette méthode a l'avantage d'être moins couteuse en temps que de vérifier case par case, en effet, on ignore les cases vides, et il suffit de regarder dans la liste des pions morts pour determiner si un pion est mort.



	\subsection{Déplacement et coups}
	Pour determiner ou le joueur peut se copier/sauter, on utilise un algoritmhe qui nous renvoie, suivant la case de départ et celle d'arrivée, le coup joué.\\
	
	Pour cela, l'algorithme va calculer un vecteur de déplacement. Ce vecteur rassemble la distance entre les deux cases, ainsi que comment elles sont orientées l'une par rapport a l'autre.\		\
	
	Au vu de vecteur il sera donc simple de déterminer si la case est joauble, et , ci c'est le cas, le type de coup jouée dans cette case.\\
	Si c'est une copie, il suffit de changer la valeur de la case puis ,si besoin, celle des ces voisines directes, sinon, il suffit de regarder les voisins de la case d'arrivée, et de modifier leur valeurs si besoin.

	\subsection{Gestion des scores}
	
	A l'issue d'une partie le nombre de pions possédés par le vainqueur est sauvegardé, ainsi que le pseudo rentré au niveau du jeu, dans un ficher .crxx.
	Cela permet d'enregistrer et d'afficher les scores les plus hauts atteints par les utilisateurs. Si l'IA remporte la partie, elle ne sauvegarde pas de score. 


\section{Graphismes}
	\subsection{Méthode choisie}
	
		Nous avons choisi de modéliser tout le jeu en utilisant la bibliothèque graphique SDL 1.2, qui nous permet de gérer le son, ainsi que les graphismes, et la souris. Nous importerons des images bitmap pour afficher le plateau et les pions.\\
		
		La SDL nous permettra également dee gérer la selection des cases, ainsi que des boutons des menus, en utilisant un système de Collide Box.
	
	\subsection{Style graphique}
	
		Nous avons choisi de faire notre hexagon dans le style synthwave (Tron Leagacy, Kung Fury, Far Cry : Blood Dragon): Couleurs néon sur du noir, et personnages cyberpunk.

\end{document}

